# -*- coding: utf-8 -*-

#! /bin/env python2
import c_zlib
import json
import struct
import sys
reload(sys)  # Reload does the trick!
sys.setdefaultencoding('UTF8')
import base64
import cert_set2
import cert_set3
import socket
# LD_PRELOAD=/usr/lib/libz.so

common_certs= {cert_set2.CertSet2Hash: cert_set2.CertSet2, cert_set3.CertSet3Hash: cert_set3.CertSet3}

def decompress_certs(data):
    common_substrings = "\x04\x02\x30\x00\x30\x1d\x06\x03\x55\x1d\x25\x04\x16\x30\x14\x06\x08\x2b\x06\x01\x05\x05\x07\x03\x01\x06\x08\x2b\x06\x01\x05\x05\x07\x03\x02\x30\x5f\x06\x09\x60\x86\x48\x01\x86\xf8\x42\x04\x01\x06\x06\x0b\x60\x86\x48\x01\x86\xfd\x6d\x01\x07\x17\x01\x30\x33\x20\x45\x78\x74\x65\x6e\x64\x65\x64\x20\x56\x61\x6c\x69\x64\x61\x74\x69\x6f\x6e\x20\x53\x20\x4c\x69\x6d\x69\x74\x65\x64\x31\x34\x20\x53\x53\x4c\x20\x43\x41\x30\x1e\x17\x0d\x31\x32\x20\x53\x65\x63\x75\x72\x65\x20\x53\x65\x72\x76\x65\x72\x20\x43\x41\x30\x2d\x61\x69\x61\x2e\x76\x65\x72\x69\x73\x69\x67\x6e\x2e\x63\x6f\x6d\x2f\x45\x2d\x63\x72\x6c\x2e\x76\x65\x72\x69\x73\x69\x67\x6e\x2e\x63\x6f\x6d\x2f\x45\x2e\x63\x65\x72\x30\x0d\x06\x09\x2a\x86\x48\x86\xf7\x0d\x01\x01\x05\x05\x00\x03\x82\x01\x01\x00\x4a\x2e\x63\x6f\x6d\x2f\x72\x65\x73\x6f\x75\x72\x63\x65\x73\x2f\x63\x70\x73\x20\x28\x63\x29\x30\x30\x09\x06\x03\x55\x1d\x13\x04\x02\x30\x00\x30\x1d\x30\x0d\x06\x09\x2a\x86\x48\x86\xf7\x0d\x01\x01\x05\x05\x00\x03\x82\x01\x01\x00\x7b\x30\x1d\x06\x03\x55\x1d\x0e\x30\x82\x01\x22\x30\x0d\x06\x09\x2a\x86\x48\x86\xf7\x0d\x01\x01\x01\x05\x00\x03\x82\x01\x0f\x00\x30\x82\x01\x0a\x02\x82\x01\x01\x00\xd2\x6f\x64\x6f\x63\x61\x2e\x63\x6f\x6d\x2f\x43\x2e\x63\x72\x6c\x30\x1d\x06\x03\x55\x1d\x0e\x04\x16\x04\x14\xb4\x2e\x67\x6c\x6f\x62\x61\x6c\x73\x69\x67\x6e\x2e\x63\x6f\x6d\x2f\x72\x30\x0b\x06\x03\x55\x1d\x0f\x04\x04\x03\x02\x01\x30\x0d\x06\x09\x2a\x86\x48\x86\xf7\x0d\x01\x01\x05\x05\x00\x30\x81\xca\x31\x0b\x30\x09\x06\x03\x55\x04\x06\x13\x02\x55\x53\x31\x10\x30\x0e\x06\x03\x55\x04\x08\x13\x07\x41\x72\x69\x7a\x6f\x6e\x61\x31\x13\x30\x11\x06\x03\x55\x04\x07\x13\x0a\x53\x63\x6f\x74\x74\x73\x64\x61\x6c\x65\x31\x1a\x30\x18\x06\x03\x55\x04\x0a\x13\x11\x47\x6f\x44\x61\x64\x64\x79\x2e\x63\x6f\x6d\x2c\x20\x49\x6e\x63\x2e\x31\x33\x30\x31\x06\x03\x55\x04\x0b\x13\x2a\x68\x74\x74\x70\x3a\x2f\x2f\x63\x65\x72\x74\x69\x66\x69\x63\x61\x74\x65\x73\x2e\x67\x6f\x64\x61\x64\x64\x79\x2e\x63\x6f\x6d\x2f\x72\x65\x70\x6f\x73\x69\x74\x6f\x72\x79\x31\x30\x30\x2e\x06\x03\x55\x04\x03\x13\x27\x47\x6f\x20\x44\x61\x64\x64\x79\x20\x53\x65\x63\x75\x72\x65\x20\x43\x65\x72\x74\x69\x66\x69\x63\x61\x74\x69\x6f\x6e\x20\x41\x75\x74\x68\x6f\x72\x69\x74\x79\x31\x11\x30\x0f\x06\x03\x55\x04\x05\x13\x08\x30\x37\x39\x36\x39\x32\x38\x37\x30\x1e\x17\x0d\x31\x31\x30\x0e\x06\x03\x55\x1d\x0f\x01\x01\xff\x04\x04\x03\x02\x05\xa0\x30\x0c\x06\x03\x55\x1d\x13\x01\x01\xff\x04\x02\x30\x00\x30\x1d\x30\x0f\x06\x03\x55\x1d\x13\x01\x01\xff\x04\x05\x30\x03\x01\x01\x00\x30\x1d\x06\x03\x55\x1d\x25\x04\x16\x30\x14\x06\x08\x2b\x06\x01\x05\x05\x07\x03\x01\x06\x08\x2b\x06\x01\x05\x05\x07\x03\x02\x30\x0e\x06\x03\x55\x1d\x0f\x01\x01\xff\x04\x04\x03\x02\x05\xa0\x30\x33\x06\x03\x55\x1d\x1f\x04\x2c\x30\x2a\x30\x28\xa0\x26\xa0\x24\x86\x22\x68\x74\x74\x70\x3a\x2f\x2f\x63\x72\x6c\x2e\x67\x6f\x64\x61\x64\x64\x79\x2e\x63\x6f\x6d\x2f\x67\x64\x73\x31\x2d\x32\x30\x2a\x30\x28\x06\x08\x2b\x06\x01\x05\x05\x07\x02\x01\x16\x1c\x68\x74\x74\x70\x73\x3a\x2f\x2f\x77\x77\x77\x2e\x76\x65\x72\x69\x73\x69\x67\x6e\x2e\x63\x6f\x6d\x2f\x63\x70\x73\x30\x34\x30\x30\x30\x30\x30\x30\x5a\x17\x0d\x31\x33\x30\x35\x30\x39\x06\x08\x2b\x06\x01\x05\x05\x07\x30\x02\x86\x2d\x68\x74\x74\x70\x3a\x2f\x2f\x73\x30\x39\x30\x37\x06\x08\x2b\x06\x01\x05\x05\x07\x02\x30\x44\x06\x03\x55\x1d\x20\x04\x3d\x30\x3b\x30\x39\x06\x0b\x60\x86\x48\x01\x86\xf8\x45\x01\x07\x17\x06\x31\x0b\x30\x09\x06\x03\x55\x04\x06\x13\x02\x47\x42\x31\x1b\x53\x31\x17\x30\x15\x06\x03\x55\x04\x0a\x13\x0e\x56\x65\x72\x69\x53\x69\x67\x6e\x2c\x20\x49\x6e\x63\x2e\x31\x1f\x30\x1d\x06\x03\x55\x04\x0b\x13\x16\x56\x65\x72\x69\x53\x69\x67\x6e\x20\x54\x72\x75\x73\x74\x20\x4e\x65\x74\x77\x6f\x72\x6b\x31\x3b\x30\x39\x06\x03\x55\x04\x0b\x13\x32\x54\x65\x72\x6d\x73\x20\x6f\x66\x20\x75\x73\x65\x20\x61\x74\x20\x68\x74\x74\x70\x73\x3a\x2f\x2f\x77\x77\x77\x2e\x76\x65\x72\x69\x73\x69\x67\x6e\x2e\x63\x6f\x6d\x2f\x72\x70\x61\x20\x28\x63\x29\x30\x31\x10\x30\x0e\x06\x03\x55\x04\x07\x13\x07\x53\x31\x13\x30\x11\x06\x03\x55\x04\x0b\x13\x0a\x47\x31\x13\x30\x11\x06\x0b\x2b\x06\x01\x04\x01\x82\x37\x3c\x02\x01\x03\x13\x02\x55\x31\x16\x30\x14\x06\x03\x55\x04\x03\x14\x31\x19\x30\x17\x06\x03\x55\x04\x03\x13\x31\x1d\x30\x1b\x06\x03\x55\x04\x0f\x13\x14\x50\x72\x69\x76\x61\x74\x65\x20\x4f\x72\x67\x61\x6e\x69\x7a\x61\x74\x69\x6f\x6e\x31\x12\x31\x21\x30\x1f\x06\x03\x55\x04\x0b\x13\x18\x44\x6f\x6d\x61\x69\x6e\x20\x43\x6f\x6e\x74\x72\x6f\x6c\x20\x56\x61\x6c\x69\x64\x61\x74\x65\x64\x31\x14\x31\x31\x30\x2f\x06\x03\x55\x04\x0b\x13\x28\x53\x65\x65\x20\x77\x77\x77\x2e\x72\x3a\x2f\x2f\x73\x65\x63\x75\x72\x65\x2e\x67\x47\x6c\x6f\x62\x61\x6c\x53\x69\x67\x6e\x31\x53\x65\x72\x76\x65\x72\x43\x41\x2e\x63\x72\x6c\x56\x65\x72\x69\x53\x69\x67\x6e\x20\x43\x6c\x61\x73\x73\x20\x33\x20\x45\x63\x72\x6c\x2e\x67\x65\x6f\x74\x72\x75\x73\x74\x2e\x63\x6f\x6d\x2f\x63\x72\x6c\x73\x2f\x73\x64\x31\x1a\x30\x18\x06\x03\x55\x04\x0a\x68\x74\x74\x70\x3a\x2f\x2f\x45\x56\x49\x6e\x74\x6c\x2d\x63\x63\x72\x74\x2e\x67\x77\x77\x77\x2e\x67\x69\x63\x65\x72\x74\x2e\x63\x6f\x6d\x2f\x31\x6f\x63\x73\x70\x2e\x76\x65\x72\x69\x73\x69\x67\x6e\x2e\x63\x6f\x6d\x30\x39\x72\x61\x70\x69\x64\x73\x73\x6c\x2e\x63\x6f\x73\x2e\x67\x6f\x64\x61\x64\x64\x79\x2e\x63\x6f\x6d\x2f\x72\x65\x70\x6f\x73\x69\x74\x6f\x72\x79\x2f\x30\x81\x80\x06\x08\x2b\x06\x01\x05\x05\x07\x01\x01\x04\x74\x30\x72\x30\x24\x06\x08\x2b\x06\x01\x05\x05\x07\x30\x01\x86\x18\x68\x74\x74\x70\x3a\x2f\x2f\x6f\x63\x73\x70\x2e\x67\x6f\x64\x61\x64\x64\x79\x2e\x63\x6f\x6d\x2f\x30\x4a\x06\x08\x2b\x06\x01\x05\x05\x07\x30\x02\x86\x3e\x68\x74\x74\x70\x3a\x2f\x2f\x63\x65\x72\x74\x69\x66\x69\x63\x61\x74\x65\x73\x2e\x67\x6f\x64\x61\x64\x64\x79\x2e\x63\x6f\x6d\x2f\x72\x65\x70\x6f\x73\x69\x74\x6f\x72\x79\x2f\x67\x64\x5f\x69\x6e\x74\x65\x72\x6d\x65\x64\x69\x61\x74\x65\x2e\x63\x72\x74\x30\x1f\x06\x03\x55\x1d\x23\x04\x18\x30\x16\x80\x14\xfd\xac\x61\x32\x93\x6c\x45\xd6\xe2\xee\x85\x5f\x9a\xba\xe7\x76\x99\x68\xcc\xe7\x30\x27\x86\x29\x68\x74\x74\x70\x3a\x2f\x2f\x63\x86\x30\x68\x74\x74\x70\x3a\x2f\x2f\x73"

    # common + cached + common_substrings
    # read the header first
    pos = 0
    certs = []
    while True:
        entry, = struct.unpack("<B", data[pos])
        if entry == 0:
            pos += 1
            break

        pos += 1
        if entry == 1: # compressed
            certs.append("compressed")
        if entry == 2: #cached (should not happen)
            certs.append("cached")
            hash, = struct.unpack("<Q", data[pos:pos+8])
            pos += 8
        if entry == 3: #common
            hash, = struct.unpack("<Q", data[pos:pos+8])
            pos += 8
            index,  = struct.unpack("<I", data[pos:pos+4])
            #we need this common cert in our decompress dict
            certs.append(common_certs[hash][index])
            common_substrings = common_certs[hash][index] + common_substrings
            pos += 4

    total_len, = struct.unpack("<I", data[pos:pos+4])
    pos += 4
    data = data[pos:]
    zlib_dict = common_substrings
    decompressor = c_zlib.Decompressor(dictionary=zlib_dict)
    raw_data = decompressor(data)

    current = 0
    while current < total_len:
        cert_len, = struct.unpack("<I", raw_data[current:current+4])
        idx = certs.index("compressed")
        certs[idx] = (raw_data[current+4:current+4+cert_len])
        current += 4 + cert_len
    return certs



def decode_tag(tag, data):
    raw_data = base64.b64decode(data)

    try:
        if tag == u"CRT\xff":                                                   # Certificates
            certs = decompress_certs(raw_data)
            b64_certs = []
            for cert in certs:
                if cert != "cached":
                    b64_certs.append(base64.b64encode(cert))
            return b64_certs

        elif tag in ('VER ', 'SCFG_AEAD', 'SCFG_KEXS'):                         # List of tags
            return [raw_data[i:i+4] for i in range(0, len(raw_data), 4)]

        elif tag in ('CFCW'):                                                   # 32-bit big endian
            return struct.unpack('>I', raw_data)[0]

        elif tag in ('STTL', 'SCFG_EXPY'):                              # 64-bit little endian
            return struct.unpack('<Q', raw_data)[0]

        elif tag in ('SFCW', 'RREJ', 'MSPC', 'SCLS', 'ICSL', 'MIDS', 'SMHL', 'NCMR'):           # 32-bit little endian
            return struct.unpack('<I', raw_data)[0]

        elif tag == 'SCFG_PUBS':                                                # SCFG Public values
            pos = 0
            pubs = []
            while pos < len(raw_data):
                l, = struct.unpack("<I", raw_data[pos:pos+3] + "\x00")
                pos += 3
                pubs.append(base64.b64encode(raw_data[pos:pos+l]))
                pos += l
            return pubs

        elif tag in ('STK ', 'SNO ', 'PROF', 'PUBS', 'SCFG_SCID', 'SCFG_OBIT'): # BLOB
            return data

        elif tag in ('SCFG_TBKP', 'SCFG_PDMD'):                                 # Strings
            return raw_data

        elif tag == u"SCFG":                                                    # SCFG
            num_tags, = struct.unpack("<H", raw_data[4:6])
            data_offset = 8+num_tags*8
            combined_offset = 0
            config = {}
            for i in range(num_tags):
                scfg_tag = raw_data[8+i*8:8+i*8+4]
                tag_offset, = struct.unpack("<I", raw_data[8+i*8+4:8+i*8+8])
                #print tag_offset, scfg_tag, data_offset+combined_offset, data_offset+tag_offset
                tag_data = base64.b64encode(raw_data[data_offset+combined_offset:data_offset+tag_offset])
                combined_offset = tag_offset
                config[scfg_tag] = decode_tag("SCFG_"+scfg_tag, tag_data)
            return config

        elif tag == "CADR":                                                     # Client address
            addr_family = struct.unpack("H", raw_data[0:2])[0]
            if addr_family == 2:
                ip = socket.inet_ntoa(raw_data[2:6])
                port = struct.unpack("H", raw_data[6:8])[0]
                return "{}:{}".format(ip, port)
            elif addr_family == 10:
                return "IPv6: {}".format(data)
            else:
                return "{}: {}".format(addr_family, data)

        else:                                                                   # Unknown
            #print repr(tag)
            return data

    except Exception as e:
        sys.stdout.write(u"Error decoding tag {}: {}\n".format(tag, e))
    return data


REJ_MSG = "rejTags"
SHLO_MSG = "shloTags"
for line in sys.stdin:
    jline = json.loads(line)
    if REJ_MSG in jline:
        for tag in jline[REJ_MSG]:
            jline[REJ_MSG][tag] = decode_tag(tag, jline[REJ_MSG][tag])
    if SHLO_MSG in jline:
        for tag in jline[SHLO_MSG]:
            jline[SHLO_MSG][tag] = decode_tag(tag, jline[SHLO_MSG][tag])
    print json.dumps(jline)
